/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
	"/files": {
		/**
		 * Read information about available files
		 * @description Information about available files is read with HTTP GET. The files for which information shall be returned are identified with the path component (base resource) and the query component (fileDataType, beginTime, endTime) of the URI.
		 */
		get: operations["filesGET"];
		/** Create a single file report */
		post: operations["filesPOST"];
	};
	"/files/{fileId}": {
		/** Get a file by ID */
		get: operations["filesGETById"];
		/** Delete a file by ID */
		delete: operations["filesDELETE"];
	};
	"/files/create_many": {
		/** Create many file reports */
		post: operations["filesPOSTMany"];
	};
	"/subscriptions": {
		/**
		 * Create a subscription
		 * @description To create a subscription the representation of the subscription is POSTed on the /subscriptions collection resource.
		 */
		post: operations["subscriptionsPOST"];
	};
	"/subscriptions/{subscriptionId}": {
		/** Get a subscription by ID */
		get: operations["getSubscription"];
		/**
		 * Delete a subscription
		 * @description The subscription is deleted by deleting the corresponding subscription resource. The resource to be deleted is identified with the path component of the URI.
		 */
		delete: operations["subscriptionsSubscriptionIdDELETE"];
	};
}

export type webhooks = Record<string, never>;

export interface components {
	schemas: {
		/** @enum {string} */
		FileDataType: "Performance" | "Trace" | "Analytics" | "Proprietary";
		/** @enum {string} */
		FileNotificationTypes: "notifyFileReady" | "notifyFilePreparationError";
		/**
		 * @example {
		 *   "fileSize": 0,
		 *   "fileLocation": "fileLocation",
		 *   "fileReadyTime": "2000-01-23T04:56:07.000Z",
		 *   "fileFormat": "fileFormat",
		 *   "fileDataType": "Performance",
		 *   "fileExpirationTime": "2000-01-23T04:56:07.000Z",
		 *   "fileCompression": "fileCompression"
		 * }
		 */
		FileInfo: {
			fileLocation: string;
			fileSize?: components["schemas"]["FileSize"];
			/** Format: date-time */
			fileReadyTime: string;
			/** Format: date-time */
			fileExpirationTime?: string;
			fileCompression?: string;
			fileFormat?: string;
			fileDataType: components["schemas"]["FileDataType"];
		};
		NotifyFileReady: components["schemas"]["NotificationHeader"] &
			components["schemas"]["NotifyFileReady_allOf"];
		NotifyFilePreparationError: components["schemas"]["NotificationHeader"] &
			components["schemas"]["NotifyFilePreparationError_allOf"];
		/**
		 * Format: date-time
		 * @description The date format shall be compliant with RFC3339.
		 * @example "2023-10-29T23:00:00.000Z"
		 */
		DateTime: string;
		/** @description Default schema for the response message body in case the request is not successful. */
		ErrorResponse: {
			error?: components["schemas"]["ErrorResponse_error"];
		};
		/**
		 * @example {
		 *   "filter": {
		 *     "fileContent": {
		 *       "hostid": "10084"
		 *     },
		 *     "fileDataType": "Performance",
		 *     "fileReadyTime": "2023-10-30T00:00:00+01:00"
		 *   },
		 *   "timeTick": 0,
		 *   "consumerReference": "consumerReference"
		 * }
		 */
		Subscription: {
			/**
			 * Format: uri
			 * @description Reference (address) of the MnS consumer to which the notifications shall be sent.
			 * @example 127.0.0.1:8080/callback
			 */
			consumerReference?: string;
			/** @description Initial value of a timer held by the MnS producer. This value defines the time window within which the MnS consumer intends to invoke the "subscribe" operation again to confirm its subscription. The value "0" shall indicate infinity. In this case the subscription is not terminated by the MnS producer. Unit is minutes */
			timeTick?: number;
			filter?: components["schemas"]["Filter"];
		};
		NotificationHeader: {
			href?: string;
			notificationId: number;
			notificationType: components["schemas"]["NotificationType"];
			/** Format: date-time */
			eventTime: string;
			systemDN: string;
		};
		NotificationId: number;
		NotificationType:
			| components["schemas"]["AlarmNotificationTypes"]
			| components["schemas"]["CmNotificationTypes"]
			| components["schemas"]["PerfNotificationTypes"]
			| components["schemas"]["HeartbeatNotificationTypes"]
			| components["schemas"]["FileNotificationTypes"];
		/**
		 * @description The filter format is a free-form JSON object.
		 * @example {
		 *   "beginTime": "2000-01-23T04:56:07.000Z",
		 *   "endTime": "2000-01-24T00:00:00.000Z",
		 *   "fileContent": {
		 *     "hostid": "10084"
		 *   },
		 *   "fileSize": 20,
		 *   "fileFormat": "fileFormat",
		 *   "fileDataType": "Performance",
		 *   "fileExpirationTime": "2000-01-23T04:56:07.000Z",
		 *   "fileCompression": "fileCompression"
		 * }
		 */
		Filter: {
			[key: string]: unknown;
		};
		/** @enum {string} */
		AlarmNotificationTypes:
			| "notifyNewAlarm"
			| "notifyChangedAlarm"
			| "notifyChangedAlarmGeneral"
			| "notifyAckStateChanged"
			| "notifyCorrelatedNotificationChanged"
			| "notifyComments"
			| "notifyClearedAlarm"
			| "notifyAlarmListRebuilt"
			| "notifyPotentialFaultyAlarmList";
		/** @enum {string} */
		CmNotificationTypes:
			| "notifyMOICreation"
			| "notifyMOIDeletion"
			| "notifyMOIAttributeValueChanges"
			| "notifyMOIChanges";
		/** @enum {string} */
		PerfNotificationTypes: "notifyThresholdCrossing";
		/** @enum {string} */
		HeartbeatNotificationTypes: "notifyHeartbeat";
		/** @example null */
		NotifyFileReady_allOf: {
			fileInfoList: components["schemas"]["FileInfo"][];
			additionalText?: string;
		};
		/** @example null */
		NotifyFilePreparationError_allOf: {
			fileInfoList: components["schemas"]["FileInfo"][];
			reason?: string;
			additionalText?: string;
		};
		ErrorResponse_error: {
			errorInfo?: string;
		};
		/** @description File data and metadata. */
		AddFile: {
			fileContent: components["schemas"]["FileContent"];
			fileSize?: components["schemas"]["FileSize"];
			/** Format: date-time */
			fileReadyTime: string;
			/** Format: date-time */
			fileExpirationTime?: string;
			fileCompression?: string;
			fileFormat?: string;
			fileDataType: components["schemas"]["FileDataType"];
		};
		FileInfoCreated: {
			fileId: string;
		};
		/**
		 * @description This data type doesn't have a specific format. It shall contain the contents of the file.
		 * @example {
		 *   "42899": {
		 *     "name": "CPU utilization",
		 *     "data": [
		 *       {
		 *         "itemid": "42899",
		 *         "clock": 1699440883,
		 *         "value": 1.4933189999996,
		 *         "ns": 597517450
		 *       },
		 *       {
		 *         "itemid": "42899",
		 *         "clock": 1699440943,
		 *         "value": 1.4521909999991,
		 *         "ns": 710613952
		 *       }
		 *     ]
		 *   },
		 *   "host": "Zabbix Server",
		 *   "hostid": 10084
		 * }
		 */
		FileContent: {
			[key: string]: unknown;
		};
		/**
		 * @description The size of the file. Its value is a non negative integer. The unit is byte.
		 * @example 1024
		 */
		FileSize: number;
	};
	responses: never;
	parameters: never;
	requestBodies: never;
	headers: never;
	pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {
	/**
	 * Read information about available files
	 * @description Information about available files is read with HTTP GET. The files for which information shall be returned are identified with the path component (base resource) and the query component (fileDataType, beginTime, endTime) of the URI.
	 */
	filesGET: {
		parameters: {
			query: {
				/** @description This parameter selects files based on the file data type. */
				fileDataType: components["schemas"]["FileDataType"];
				/** @description This parameter selects files based on the earliest time they became available */
				beginTime?: components["schemas"]["DateTime"];
				/** @description This parameter selects files based on the latest time they became available */
				endTime?: components["schemas"]["DateTime"];
			};
		};
		responses: {
			/** @description 'Success case ("200 OK"). The resources identified in the request for retrieval are returned in the response message body.' */
			200: {
				content: {
					"application/json": components["schemas"]["FileInfo"][];
				};
			};
			/** @description Error case. */
			default: {
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	/** Create a single file report */
	filesPOST: {
		requestBody: {
			content: {
				"application/json": components["schemas"]["AddFile"];
			};
		};
		responses: {
			/** @description 'Success case ("201 Created"). The resource has been successfully created.' */
			201: {
				content: {
					"application/json": components["schemas"]["FileInfoCreated"];
				};
			};
			/** @description Error case. */
			default: {
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	/** Get a file by ID */
	filesGETById: {
		parameters: {
			path: {
				fileId: string;
			};
		};
		responses: {
			/** @description 'Success case ("200 OK"). The resources identified in the request for retrieval are returned in the response message body.' */
			200: {
				content: {
					"application/json": {
						fileInfo: components["schemas"]["FileInfo"];
						[key: string]: unknown;
					};
				};
			};
			/** @description A file with specified ID was not found. */
			404: {
				content: never;
			};
			/** @description Error case. */
			default: {
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	/** Delete a file by ID */
	filesDELETE: {
		parameters: {
			path: {
				fileId: string;
			};
		};
		responses: {
			/** @description 'Success case ("200 OK"). The resource identified in the request for deletion is returned in the response message body.' */
			200: {
				content: {
					"application/json": {
						fileInfo: components["schemas"]["FileInfo"];
						[key: string]: unknown;
					};
				};
			};
			/** @description A file with specified ID was not found. */
			404: {
				content: never;
			};
			/** @description Error case. */
			default: {
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	/** Create many file reports */
	filesPOSTMany: {
		requestBody: {
			content: {
				"application/json": components["schemas"]["AddFile"][];
			};
		};
		responses: {
			/** @description 'Success case ("201 Created"). The resource has been successfully created.' */
			201: {
				content: {
					"application/json": string[];
				};
			};
			/** @description Error case. */
			default: {
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	/**
	 * Create a subscription
	 * @description To create a subscription the representation of the subscription is POSTed on the /subscriptions collection resource.
	 */
	subscriptionsPOST: {
		requestBody: {
			content: {
				"application/json": components["schemas"]["Subscription"];
			};
		};
		responses: {
			/** @description Success case ("201 Created"). The representation of the newly created subscription resource shall be returned. */
			201: {
				headers: {
					/** @description URI of the newly created subscription resource */
					Location: string;
				};
				content: {
					"application/json": components["schemas"]["Subscription"];
				};
			};
			/** @description Error case. */
			default: {
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	/** Get a subscription by ID */
	getSubscription: {
		parameters: {
			path: {
				subscriptionId: string;
			};
		};
		responses: {
			/** @description 'Success case ("200 OK"). The resources identified in the request for retrieval are returned in the response message body.' */
			200: {
				content: {
					"application/json": components["schemas"]["Subscription"];
				};
			};
			/** @description A subscription with specified ID was not found. */
			404: {
				content: never;
			};
			/** @description Error case. */
			default: {
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
	/**
	 * Delete a subscription
	 * @description The subscription is deleted by deleting the corresponding subscription resource. The resource to be deleted is identified with the path component of the URI.
	 */
	subscriptionsSubscriptionIdDELETE: {
		parameters: {
			path: {
				/** @description Identifies the subscription to be deleted. */
				subscriptionId: string;
			};
		};
		responses: {
			/** @description Success case ("204 No Content"). The subscription resource has been deleted. The response message body is absent. */
			204: {
				content: never;
			};
			/** @description Error case. */
			default: {
				content: {
					"application/json": components["schemas"]["ErrorResponse"];
				};
			};
		};
	};
}
